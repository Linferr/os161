Step 4:
-------------------------sys161 output------------
sys161: System/161 release 2.0.3, compiled Aug 10 2015 13:31:07

OS/161 base system version 1.99.08
Copyright (c) 2000, 2001-2005, 2008-2011, 2013, 2014
   President and Fellows of Harvard College.  All rights reserved.

Put-your-group-name-here's system version 0 (DUMBVM #1)

292k physical memory available
Device probe...
lamebus0 (system main bus)
emu0 at lamebus0
ltrace0 at lamebus0
ltimer0 at lamebus0
beep0 at ltimer0
rtclock0 at ltimer0
lrandom0 at lamebus0
random0 at lrandom0
lhd0 at lamebus0
lhd1 at lamebus0
lser0 at lamebus0
con0 at lser0

cpu0: MIPS/161 (System/161 2.x) features 0x0
OS/161 kernel [? for menu]:

---------------git log output-----------------------
commit 5c8d1ec0b2cc25e0b9e520e861e61402fea63d26 (HEAD -> master, tag: asst1-start, origin/master)
Author: Linfeng Gao <gao0723@ssh-linux3.ece.ubc.ca>
Date:   Mon Sep 12 23:57:23 2022 -0700

    Initial commit of os161 for CPEN331

---------------git tag output------------------
asst1-start

-----------------------------------------------------------------
Step5. Complete the code reading exercise

Question 1: In the book chapters and in class you were introduced to the mechanisms used to 
transfer control between user processes and the operating system. Tell us where we can find 
the first line of OS/161 code that is executed when a trap occurs. Then tell us where control
gets transferred to from that point. What about an interrupt? How does that differ?

A trap is a software-produced interrupt, which I think the first should be handled by 
either mips_utlb_handler or mips_general_handler. 
Both of them are in the: os161/src/kern/arch/mips/locore/exception-mips1.S.
line 68: mips_utlb_handler
line 86: mips_general_handler

Both of them jump to common_exception (line 104), 
set up the trap_frame, and than call mips_trap.
mips_trap() is in os161/src/kern/arch/mips/locore/trap.c, line 125.
It is a general trap(exception) handling function for mips, which means different type would go to different handler.
For example, syscall would call the syscall handler and return.

The trap is a special kind of interrupt, which is commonly referred to software intrupt.
In this case, the first part of trap and interrupt are the same, until get in the mips_trap(), which may .
The interupt would than go to (line188) mainbus_interrupt() to be handled.

Also, the processor turned interrupts off when it took the trap.




Question 2: Making a system call, such as write, ultimately leads to a trap. Find the code 
in OS/161 that invokes system calls from user programs and causes traps. In which file and on 
which lines did you find this code?

os161/src/userland/lib/libc/arch/mips/syscalls-mips.S
The comment said that all we do is load the syscall number into v0, 
and kernel would find it and jump to the shared syscall code.

line 49: #define SYSCALL(sym, num), the high level define.
line 55: jump to __syscall, here jump to the real function.
line 83: __syscall function, this is the real function invokes system calls from userland.





Question 3: Why do you suppose there are libc functions in the "common" part of the source
tree (common/libc) as well as in userland/lib/libc?

common/libc is something shared by both kernel and userï¼Œand mostly standard C library functions;
while userland/lib/libc is only for users.
The seperation is to avoid the possible users-caused problem and protecting the system. 





Question 4: Name two things that configure configures. What might invalidate that configuration and 
make you need/want to rerun it?

no idea



Question 5: What are some of the details which would make a function "machine dependent"? Why might it be 
important to maintain this separation, instead of just putting all of the code in one function?




Question 6: How large is a trapframe? Why?





Question 7: Under what circumstances should you re-run the kern/conf/config script?




Question 8: Under what circumstances should you run bmake depend in kern/compile/DUMBVM?




Question 9: Under what circumstances should you run bmake or bmake install in kern/compile/DUMBVM?





Question 10: When you booted your kernel, you found that there were several commands that you could issue 
to experiment with it. Explain exactly where and what you would have to do to add a command that printed 
out, "Hello world!"





Question 11: Why do we need to include these in your OS/161 distribution? Why can't you just use the 
standard utilities that are present on the machine on which you're working?




Question 12: When a user program exits, what is done with the program's return value?






Question 13: Imagine that you wanted to add a new system call. List all the places that you would 
need to modify/add code. Then review your answers to questions 7-9 and note which of those actions 
you need to take in order to test the new system call.